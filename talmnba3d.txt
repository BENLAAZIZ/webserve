
void Server::handleClientData(std::size_t index) {
    char buffer[BUFFER_SIZE];
    int client_fd = pollfds[index].fd;

    std::size_t bytes_read = recv(client_fd, buffer, BUFFER_SIZE - 1, 0);
    if (bytes_read <= 0) {
        if (bytes_read == 0) {
            std::cout << "Client disconnected fd: " << client_fd << std::endl;
        } else {
            std::cerr << "Receive error: " << strerror(errno) << std::endl;
        }
        close(client_fd);
        pollfds.erase(pollfds.begin() + index);
        clientBuffers.erase(client_fd);
        requests.erase(client_fd);
        return;
    }

    buffer[bytes_read] = '\0';
    clientBuffers[client_fd] += buffer; // Append received data to buffer

    // Check if headers are completely received
    size_t headersEnd = clientBuffers[client_fd].find("\r\n\r\n");
    if (headersEnd != std::string::npos) {
        // Extract headers
        std::string headers = clientBuffers[client_fd].substr(0, headersEnd);
        clientBuffers[client_fd].erase(0, headersEnd + 4); // Remove headers from buffer
        flag_end_of_headers = true;

        // Process headers
        std::istringstream headerStream(headers);

		// parse first line
		if (requests[client_fd].getMethod().empty())
		{
			std::string firstLine;
			std::getline(headerStream, firstLine);
			if (!requests[client_fd].parseFirstLine(firstLine)) {
				requests[client_fd].sendErrorResponse(400);
				std::cout << "400 Bad Request" << std::endl;
			return;
		}
		std::cout << "Method: " << requests[client_fd].getMethod() << "\nPath: " << requests[client_fd].getpath() << "\nVersion: " << requests[client_fd].getVersion() << std::endl;
		}
		
        std::string line;
        while (std::getline(headerStream, line) && line != "\r") {
            size_t colonPos = line.find(":");
            if (colonPos != std::string::npos) {
                std::string key = line.substr(0, colonPos);
                std::string value = line.substr(colonPos + 1);
                value.erase(0, value.find_first_not_of(" ")); // Trim spaces
                std::transform(key.begin(), key.end(), key.begin(), ::tolower);
                requests[client_fd].setHeader(key, value);
            }
        }

        // Check if Content-Length or Chunked Transfer Encoding exists
        std::string contentLengthStr = requests[client_fd].getHeader("content-length");
        std::string transferEncoding = requests[client_fd].getHeader("transfer-encoding");

        if (!contentLengthStr.empty()) {
            int contentLength = std::stoi(contentLengthStr);
            requests[client_fd].setContentLength(contentLength);
            if (clientBuffers[client_fd].size() >= (size_t)contentLength) {
                requests[client_fd].setBody(clientBuffers[client_fd].substr(0, contentLength));
                clientBuffers[client_fd].erase(0, contentLength);
                // handleRequest(client_fd, requests[client_fd]); // Process request
                requests[client_fd] = HTTPRequest(); // Reset for next request
            }
        } else if (transferEncoding == "chunked") {
            // requests[client_fd].setChunked(true);
			std::cout << "Chunked Transfer Encoding" << std::endl;
        } else {
            // No body, process request immediately
            // handleRequest(client_fd, requests[client_fd]);
            requests[client_fd] = HTTPRequest(); // Reset for next request
		std::cout << "================================================" << std::endl;
        }
		// std::cout << "Request: " << requests[client_fd].getMethod() << " " << requests[client_fd].getpath() << std::endl;
    }
	
}

////////////////////////////////////////////////////////////////////////////////////////
akhir update
//////////////////////////////////////////////////////////////////////////////////////





void Server::handleClientData(std::size_t index) {
	char buffer[BUFFER_SIZE];
	int client_fd = pollfds[index].fd;

	std::size_t bytes_read = recv(client_fd, buffer, BUFFER_SIZE - 1, 0);
	if (bytes_read <= 0) {
		if (bytes_read == 0) {
			std::cout << "Client disconnected fd: " << client_fd << std::endl;
		} else {
			std::cerr << "Receive error: " << strerror(errno) << std::endl;
		}
		close(client_fd);
		pollfds.erase(pollfds.begin() + index);
		clientBuffers.erase(client_fd);  // Clean up client buffer
		requests.erase(client_fd);
		return;
	}

	buffer[bytes_read] = '\0';
	clientBuffers[client_fd] += buffer; // Append new data to client's buffer

	// Check for end of headers ("\r\n\r\n")
	if(requests[client_fd].getFlagEndOfHeaders() == false)
	{
		
	}
	size_t headerEndPos = clientBuffers[client_fd].find("\r\n\r\n");
	if (headerEndPos != std::string::npos) {
		flag_end_of_headers = true;
		// Extract body (if any) after \r\n\r\n
		// std::size_t bodyStartPos = headerEndPos + 4; // Move past \r\n\r\n
		// if (bodyStartPos < clientBuffers[client_fd].size()) {
		// 	requests[client_fd].setBody(requests[client_fd].getBody() + clientBuffers[client_fd].substr(bodyStartPos));
		// 	clientBuffers[client_fd].erase(bodyStartPos); // Remove body from buffer
		// }
	}

	// if (flag_end_of_headers) {
	// 	std::cout << "End of headers found" << std::endl;
	// }
	

	// Process data line by line
	while (1 && !flag_body) {
		size_t lineEnd = clientBuffers[client_fd].find("\r\n");
		if (lineEnd == std::string::npos) {
			// std::cout << "No complete line found, wait for more data" << std::endl;
			break; // Wait for more data
		}
		std::string line = clientBuffers[client_fd].substr(0, lineEnd);
		clientBuffers[client_fd].erase(0, lineEnd + 2); // Remove processed line

		if (requests[client_fd].getMethod().empty() || requests[client_fd].getpath().empty() || requests[client_fd].getVersion().empty()) {
			if (!requests[client_fd].parseFirstLine(line)) {
				std::cout << "400 Bad Request" << std::endl;
				return;
			}
			std::cout << "----------------->First Line method: |" << requests[client_fd].getMethod() << "|" << std::endl;
		}
		else {
			if (line.empty()) {
				std::cout << "End of headers" << std::endl;
				if (requests[client_fd].getHeaders().find("host") == requests[client_fd].getHeaders().end()) {
					requests[client_fd].sendErrorResponse(400);
					std::cout << "-- Host header missing 400 --" << std::endl;
					return;
				}

				// Handle POST request body

				// if (requests[client_fd].getMethod() == "POST") {
				// 	if (requests[client_fd].getHeader("Transfer-Encoding") == "chunked") {
				// 		std::cout << "-- Chunked encoding detected, handling separately --" << std::endl;
				// 		// Implement chunked transfer decoding here
				// 	}
				// 	else {
				// 		std::string contentLength = requests[client_fd].getHeader("Content-Length");
				// 		if (contentLength.empty()) {
				// 			requests[client_fd].sendErrorResponse(411);
				// 			std::cout << "-- Content-Length header missing 411 --" << std::endl;
				// 			return;
				// 		}
				// 		requests[client_fd].setContentLength(std::atoi(contentLength.c_str()));
				// 		std::cout << "**Content-Length:** " << requests[client_fd].getContentLength() << std::endl;
				// 	}
				// } 

				break;
			}

			size_t colonPos = line.find(":");
			if (colonPos == std::string::npos || colonPos == 0 || line[colonPos - 1] == ' ') {
				requests[client_fd].sendErrorResponse(400);
				std::cout << "-- Malformed header 400 --" << std::endl;
				return;
			}
			std::string key = line.substr(0, colonPos);
			std::transform(key.begin(), key.end(), key.begin(), ::tolower);
			std::string value = line.substr(colonPos + 1);
			value.erase(0, value.find_first_not_of(" "));

			requests[client_fd].setHeader(key, value);
			std::cout << "Header: ||" << key << "|| = ||" << value << "||" << std::endl;
		}
	}

	// Process GET, DELETE, or complete POST request
	if (flag_end_of_headers) {

		// handleRequest(client_fd, requests[client_fd]);
		requests[client_fd] = HTTPRequest(); // Reset for next request
		flag_end_of_headers = false;
	}
		
}
-------------------------
--------------------------
----------------------------
// std::string HTTPRequest::trim(const std::string& str)
// {
// 	size_t first = str.find_first_not_of(" \t\n\r");
// 	size_t last = str.find_last_not_of(" \t\n\r");
// 	if (first == std::string::npos || last == std::string::npos)
// 		return "";
// 	return str.substr(first, last - first + 1);
// }

===========================================
//=============================================================================================
// i am working in websever project at 1337 school . my part now is the handler parse request that coming from client  especially for methods: (GET , POST and DELETE).
// this request line can come of parts According to size of buffer #define BUFFER_SIZE 10
// example request :
// GET /html HTTP/1.1\r\nHost: localhost:8080\r\nTransfer-Encoding: chunked\r\nContent-Length: 39\r\nContent-Type: multipart/form-data;\r\n\r\n
// we know that the header terminate with 2 CRLF "\r\n\r\n"

// for the parsing :

// parse the firs line GET /html HTTP/1.1\r\n intel CRLF "\r\n"
----------------
	buffer[bytes_read] = '\0';
	clientBuffers[client_fd] += buffer; // Append new data to client's buffer

	// Check for end of headers ("\r\n\r\n")
	if(!requests[client_fd].getFlagEndOfHeaders())
	{
		// size_t headerEndPos = clientBuffers[client_fd].find("\r\n\r\n");
		// if (headerEndPos != std::string::npos) {
		// 	requests[client_fd].setFlagEndOfHeaders(true);
		// 	std::cout << "End of headers" << std::endl;
		// }

		// // Process data line by line
		// while (1) {
		// 	size_t lineEnd = clientBuffers[client_fd].find("\r\n");
		// 	if (lineEnd == std::string::npos) {
		// 		break; // Wait for more data
		// 	}
		// 	std::string line = clientBuffers[client_fd].substr(0, lineEnd);
		// 	clientBuffers[client_fd].erase(0, lineEnd + 2); // Remove processed line

		// 	if (requests[client_fd].getMethod().empty() || requests[client_fd].getpath().empty() || requests[client_fd].getVersion().empty()) {
		// 		if (!requests[client_fd].parseFirstLine(line)) {
		// 			requests[client_fd].sendErrorResponse(requests[client_fd].getStatusCode());
		// 			std::cout << requests[client_fd].getStatusCodeMessage() << std::endl;
		// 			return;
		// 		}
		// 		std::cout << "----------------->First Line method: |" << requests[client_fd].getMethod() << "|" << std::endl;
		// 	}
		// 	else {
		// 		if (line.empty()) {
		// 			std::cout << "End of headers" << std::endl;
		// 			if (requests[client_fd].getHeaders().find("host") == requests[client_fd].getHeaders().end()) {
		// 				requests[client_fd].sendErrorResponse(400);
		// 				std::cout << "-- Host header missing 400 --" << std::endl;
		// 				std::cout << requests[client_fd].getStatusCodeMessage() << std::endl;
		// 				return;
		// 			}
		// 			break;
		// 		}
		// 		size_t colonPos = line.find(":");
		// 		if (colonPos == std::string::npos || colonPos == 0 || line[colonPos - 1] == ' ') {
		// 			requests[client_fd].sendErrorResponse(400);
		// 			std::cout << "-- Malformed header 400 --" << std::endl;
		// 			std::cout << requests[client_fd].getStatusCodeMessage() << std::endl;
		// 			return;
		// 		}
		// 		std::string hostHeader = line.substr(0, colonPos);
		// 		std::string key;
		// 		std::transform(hostHeader.begin(), hostHeader.end(), hostHeader.begin(), ::tolower);
		// 		if (hostHeader == "host")
		// 			key = hostHeader.substr(0, colonPos);
		// 		else
		// 			key = line.substr(0, colonPos);
		// 		std::string value = line.substr(colonPos + 1);
		// 		value.erase(0, value.find_first_not_of(" ")); // Trim leading spaces

		// 		requests[client_fd].setHeader(key, value);
		// 		std::cout << "Header: ||" << key << "|| = ||" << value << "||" << std::endl;
		// 	}
			if (!requests[client_fd].parseHeader(clientBuffers[client_fd])) {
				std::cout << "Error" << std::endl;
			}
		// }

		// Process GET, DELETE, or complete POST request
		// if (requests[client_fd].getFlagEndOfHeaders()) {

		// 	// handleRequest(client_fd, requests[client_fd]);
		// 	requests[client_fd] = HTTPRequest(); // Reset for next request
		// 	requests[client_fd].setFlagEndOfHeaders(false);
		// }
	}